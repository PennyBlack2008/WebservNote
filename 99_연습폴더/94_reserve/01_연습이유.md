# [std::string::reserve](http://cplusplus.com/reference/string/string/reserve/)

연습 이유: ``char buffer[BUFFER_SIZE]`` 를 std::string 으로 변환하고 그것을 다시 c_str 로 변환할 때 변환 스타일에 따른 buffer 의 손상을 고려하지 못해 디버깅을 하는 데 시간을 많이 썼다. 지금은 c_str 로 변환할 때, NUL 값을 받고 종료하는 c_str 의 변환 방법 때문에 문자열로 구성되지 않은 binary file, 예를 들어 png 같은 경우는 문제가 생긴다. 

디버깅을 하면서 Minckim 님이 디버깅의 결론인 메소드가 reserve 이다. 나는 reserve 가 어떤 역할을 하는 지 모르고, 과연 binary 에서 string 으로 변환했다가 c_str 으로 변환할 때의 맥락과 맞는 지 확인해보고 싶다. 그리고 이 reserve 라는 것을 사용해보셔서 검색 없이 이 메소드를 아시는 것같은데 그 만큼 가끔 사용되는 메소드라는 것을 뜻하는 것같아서 한번 이 메소드를 공부해야할 필요성을 느꼈다.

### Request a change in capacity

최대 n 자 길이로 계획된 크기 변경에 맞게 문자열 용량을 조정하도록 요청한다.

### [Reserve 는 필요 없이 메모리가 재할당되는 것을 막아준다.](https://www.ikpil.com/514)

사전 지식으로, vector 와 string 은 우리가 동적할당된 것처럼 사용할 수 있는 이유는,

배열 처럼 차례대로 메모리에 올리기 위해서 vector 와 string 은 미리 메모리 공간을 기본값만큼 할당 받아 놓고, 메모리가 새롭게 추가 되면, 이 공간에 넣어 둠으로써 배열처럼 작동시키는 것이다. 이 할당 받아 놓은것을 최대 용량으로 표현하겠다.

그렇다면 어떻게 vector 와 string에 들어가는 원소의 갯수에 제한이 없느냐?
vector 와 string 은 둘다 원소가 들어올때마다 원소의 갯수를 카운팅을 하여,  최대용량과 큰지 비교하여, 크다면, 최대용량을 두배만큼 메모리를 다시 할당 받아 놓고, 기존의 원소를 새로 할당한 메모리에 순서데로 넣고, 기존 컨테이너의 모든 원소를 소멸시킨다.

reserve() 함수를 호출하여, 컨테이너 용량(최대로 담을 수 있는 원소의 갯수)을 내가 예측할 수 있는 최대 범위만큼 할당해 놓아, 재할당 비용을 면제받아야한다.

글쓴이 추천 함수 (ft_container 를 진행하려면 알아야하는 것같다..)
- size() 함수, 현재 원소의 갯수를 알려 준다.(부하는 거의 없다고 본다, 카운팅이 되기에...)
- capacity() 함수, 최대 용량을 알려 준다. (더 담을수 있는 용량이 아닌 최대 용량이다)
- resize(size_t n) 함수, 컨테이너의 원소의 갯수를 인자 만큼 늘려주거나 줄여 준다.
- reserve(size_t n) 함수, 최대 용량을 n개로 만들어 준다.(기존 최대용량보다 작으면 무시 된다.)

